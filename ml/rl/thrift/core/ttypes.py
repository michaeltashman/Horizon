#
# Autogenerated by Thrift Compiler (0.10.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py
#

from thrift.Thrift import TType, TMessageType, TFrozenDict, TException, TApplicationException
from thrift.protocol.TProtocol import TProtocolException
import sys

from thrift.transport import TTransport


class RLParameters(object):
    """
    Attributes:
     - gamma
     - epsilon
     - target_update_rate
     - reward_burnin
     - maxq_learning
     - reward_boost
     - temperature
     - softmax_policy
     - use_seq_num_diff_as_time_diff
     - q_network_loss
     - set_missing_value_to_zero
     - tensorboard_logging_freq
     - predictor_atol_check
     - predictor_rtol_check
     - time_diff_unit_length
     - multi_steps
     - ratio_different_predictions_tolerance
    """

    thrift_spec = (
        None,  # 0
        (1, TType.DOUBLE, 'gamma', None, 0.9, ),  # 1
        (2, TType.DOUBLE, 'epsilon', None, 0.1, ),  # 2
        (3, TType.DOUBLE, 'target_update_rate', None, 0.001, ),  # 3
        (4, TType.I32, 'reward_burnin', None, 1, ),  # 4
        (5, TType.BOOL, 'maxq_learning', None, True, ),  # 5
        (6, TType.MAP, 'reward_boost', (TType.STRING, 'UTF8', TType.DOUBLE, None, False), None, ),  # 6
        (7, TType.DOUBLE, 'temperature', None, 0.01, ),  # 7
        (8, TType.I32, 'softmax_policy', None, 1, ),  # 8
        (9, TType.BOOL, 'use_seq_num_diff_as_time_diff', None, False, ),  # 9
        (10, TType.STRING, 'q_network_loss', 'UTF8', "mse", ),  # 10
        (11, TType.BOOL, 'set_missing_value_to_zero', None, False, ),  # 11
        (12, TType.I32, 'tensorboard_logging_freq', None, None, ),  # 12
        (13, TType.DOUBLE, 'predictor_atol_check', None, 0, ),  # 13
        (14, TType.DOUBLE, 'predictor_rtol_check', None, 5e-05, ),  # 14
        (15, TType.DOUBLE, 'time_diff_unit_length', None, 1, ),  # 15
        (16, TType.I32, 'multi_steps', None, None, ),  # 16
        (17, TType.DOUBLE, 'ratio_different_predictions_tolerance', None, None, ),  # 17
    )

    def __init__(self, gamma=thrift_spec[1][4], epsilon=thrift_spec[2][4], target_update_rate=thrift_spec[3][4], reward_burnin=thrift_spec[4][4], maxq_learning=thrift_spec[5][4], reward_boost=None, temperature=thrift_spec[7][4], softmax_policy=thrift_spec[8][4], use_seq_num_diff_as_time_diff=thrift_spec[9][4], q_network_loss=thrift_spec[10][4], set_missing_value_to_zero=thrift_spec[11][4], tensorboard_logging_freq=None, predictor_atol_check=thrift_spec[13][4], predictor_rtol_check=thrift_spec[14][4], time_diff_unit_length=thrift_spec[15][4], multi_steps=None, ratio_different_predictions_tolerance=None,):
        self.gamma = gamma
        self.epsilon = epsilon
        self.target_update_rate = target_update_rate
        self.reward_burnin = reward_burnin
        self.maxq_learning = maxq_learning
        self.reward_boost = reward_boost
        self.temperature = temperature
        self.softmax_policy = softmax_policy
        self.use_seq_num_diff_as_time_diff = use_seq_num_diff_as_time_diff
        self.q_network_loss = q_network_loss
        self.set_missing_value_to_zero = set_missing_value_to_zero
        self.tensorboard_logging_freq = tensorboard_logging_freq
        self.predictor_atol_check = predictor_atol_check
        self.predictor_rtol_check = predictor_rtol_check
        self.time_diff_unit_length = time_diff_unit_length
        self.multi_steps = multi_steps
        self.ratio_different_predictions_tolerance = ratio_different_predictions_tolerance

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.DOUBLE:
                    self.gamma = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.DOUBLE:
                    self.epsilon = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.DOUBLE:
                    self.target_update_rate = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.reward_burnin = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.BOOL:
                    self.maxq_learning = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.MAP:
                    self.reward_boost = {}
                    (_ktype1, _vtype2, _size0) = iprot.readMapBegin()
                    for _i4 in range(_size0):
                        _key5 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        _val6 = iprot.readDouble()
                        self.reward_boost[_key5] = _val6
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.DOUBLE:
                    self.temperature = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.I32:
                    self.softmax_policy = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.BOOL:
                    self.use_seq_num_diff_as_time_diff = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 10:
                if ftype == TType.STRING:
                    self.q_network_loss = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 11:
                if ftype == TType.BOOL:
                    self.set_missing_value_to_zero = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 12:
                if ftype == TType.I32:
                    self.tensorboard_logging_freq = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 13:
                if ftype == TType.DOUBLE:
                    self.predictor_atol_check = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 14:
                if ftype == TType.DOUBLE:
                    self.predictor_rtol_check = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 15:
                if ftype == TType.DOUBLE:
                    self.time_diff_unit_length = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 16:
                if ftype == TType.I32:
                    self.multi_steps = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 17:
                if ftype == TType.DOUBLE:
                    self.ratio_different_predictions_tolerance = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('RLParameters')
        if self.gamma is not None:
            oprot.writeFieldBegin('gamma', TType.DOUBLE, 1)
            oprot.writeDouble(self.gamma)
            oprot.writeFieldEnd()
        if self.epsilon is not None:
            oprot.writeFieldBegin('epsilon', TType.DOUBLE, 2)
            oprot.writeDouble(self.epsilon)
            oprot.writeFieldEnd()
        if self.target_update_rate is not None:
            oprot.writeFieldBegin('target_update_rate', TType.DOUBLE, 3)
            oprot.writeDouble(self.target_update_rate)
            oprot.writeFieldEnd()
        if self.reward_burnin is not None:
            oprot.writeFieldBegin('reward_burnin', TType.I32, 4)
            oprot.writeI32(self.reward_burnin)
            oprot.writeFieldEnd()
        if self.maxq_learning is not None:
            oprot.writeFieldBegin('maxq_learning', TType.BOOL, 5)
            oprot.writeBool(self.maxq_learning)
            oprot.writeFieldEnd()
        if self.reward_boost is not None:
            oprot.writeFieldBegin('reward_boost', TType.MAP, 6)
            oprot.writeMapBegin(TType.STRING, TType.DOUBLE, len(self.reward_boost))
            for kiter7, viter8 in self.reward_boost.items():
                oprot.writeString(kiter7.encode('utf-8') if sys.version_info[0] == 2 else kiter7)
                oprot.writeDouble(viter8)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.temperature is not None:
            oprot.writeFieldBegin('temperature', TType.DOUBLE, 7)
            oprot.writeDouble(self.temperature)
            oprot.writeFieldEnd()
        if self.softmax_policy is not None:
            oprot.writeFieldBegin('softmax_policy', TType.I32, 8)
            oprot.writeI32(self.softmax_policy)
            oprot.writeFieldEnd()
        if self.use_seq_num_diff_as_time_diff is not None:
            oprot.writeFieldBegin('use_seq_num_diff_as_time_diff', TType.BOOL, 9)
            oprot.writeBool(self.use_seq_num_diff_as_time_diff)
            oprot.writeFieldEnd()
        if self.q_network_loss is not None:
            oprot.writeFieldBegin('q_network_loss', TType.STRING, 10)
            oprot.writeString(self.q_network_loss.encode('utf-8') if sys.version_info[0] == 2 else self.q_network_loss)
            oprot.writeFieldEnd()
        if self.set_missing_value_to_zero is not None:
            oprot.writeFieldBegin('set_missing_value_to_zero', TType.BOOL, 11)
            oprot.writeBool(self.set_missing_value_to_zero)
            oprot.writeFieldEnd()
        if self.tensorboard_logging_freq is not None:
            oprot.writeFieldBegin('tensorboard_logging_freq', TType.I32, 12)
            oprot.writeI32(self.tensorboard_logging_freq)
            oprot.writeFieldEnd()
        if self.predictor_atol_check is not None:
            oprot.writeFieldBegin('predictor_atol_check', TType.DOUBLE, 13)
            oprot.writeDouble(self.predictor_atol_check)
            oprot.writeFieldEnd()
        if self.predictor_rtol_check is not None:
            oprot.writeFieldBegin('predictor_rtol_check', TType.DOUBLE, 14)
            oprot.writeDouble(self.predictor_rtol_check)
            oprot.writeFieldEnd()
        if self.time_diff_unit_length is not None:
            oprot.writeFieldBegin('time_diff_unit_length', TType.DOUBLE, 15)
            oprot.writeDouble(self.time_diff_unit_length)
            oprot.writeFieldEnd()
        if self.multi_steps is not None:
            oprot.writeFieldBegin('multi_steps', TType.I32, 16)
            oprot.writeI32(self.multi_steps)
            oprot.writeFieldEnd()
        if self.ratio_different_predictions_tolerance is not None:
            oprot.writeFieldBegin('ratio_different_predictions_tolerance', TType.DOUBLE, 17)
            oprot.writeDouble(self.ratio_different_predictions_tolerance)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class RainbowDQNParameters(object):
    """
    Attributes:
     - double_q_learning
     - dueling_architecture
     - bcq
     - bcq_drop_threshold
    """

    thrift_spec = (
        None,  # 0
        (1, TType.BOOL, 'double_q_learning', None, True, ),  # 1
        (2, TType.BOOL, 'dueling_architecture', None, True, ),  # 2
        (3, TType.BOOL, 'bcq', None, False, ),  # 3
        (4, TType.DOUBLE, 'bcq_drop_threshold', None, 0.1, ),  # 4
    )

    def __init__(self, double_q_learning=thrift_spec[1][4], dueling_architecture=thrift_spec[2][4], bcq=thrift_spec[3][4], bcq_drop_threshold=thrift_spec[4][4],):
        self.double_q_learning = double_q_learning
        self.dueling_architecture = dueling_architecture
        self.bcq = bcq
        self.bcq_drop_threshold = bcq_drop_threshold

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.BOOL:
                    self.double_q_learning = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BOOL:
                    self.dueling_architecture = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.BOOL:
                    self.bcq = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.DOUBLE:
                    self.bcq_drop_threshold = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('RainbowDQNParameters')
        if self.double_q_learning is not None:
            oprot.writeFieldBegin('double_q_learning', TType.BOOL, 1)
            oprot.writeBool(self.double_q_learning)
            oprot.writeFieldEnd()
        if self.dueling_architecture is not None:
            oprot.writeFieldBegin('dueling_architecture', TType.BOOL, 2)
            oprot.writeBool(self.dueling_architecture)
            oprot.writeFieldEnd()
        if self.bcq is not None:
            oprot.writeFieldBegin('bcq', TType.BOOL, 3)
            oprot.writeBool(self.bcq)
            oprot.writeFieldEnd()
        if self.bcq_drop_threshold is not None:
            oprot.writeFieldBegin('bcq_drop_threshold', TType.DOUBLE, 4)
            oprot.writeDouble(self.bcq_drop_threshold)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class CNNParameters(object):
    """
    Attributes:
     - conv_dims
     - conv_height_kernels
     - conv_width_kernels
     - pool_kernels_strides
     - pool_types
     - num_input_channels
     - input_height
     - input_width
    """

    thrift_spec = (
        None,  # 0
        (1, TType.LIST, 'conv_dims', (TType.I32, None, False), None, ),  # 1
        (2, TType.LIST, 'conv_height_kernels', (TType.I32, None, False), None, ),  # 2
        (3, TType.LIST, 'conv_width_kernels', (TType.I32, None, False), None, ),  # 3
        (4, TType.LIST, 'pool_kernels_strides', (TType.I32, None, False), None, ),  # 4
        (5, TType.LIST, 'pool_types', (TType.STRING, 'UTF8', False), None, ),  # 5
        (6, TType.I32, 'num_input_channels', None, None, ),  # 6
        (7, TType.I32, 'input_height', None, None, ),  # 7
        (8, TType.I32, 'input_width', None, None, ),  # 8
    )

    def __init__(self, conv_dims=None, conv_height_kernels=None, conv_width_kernels=None, pool_kernels_strides=None, pool_types=None, num_input_channels=None, input_height=None, input_width=None,):
        self.conv_dims = conv_dims
        self.conv_height_kernels = conv_height_kernels
        self.conv_width_kernels = conv_width_kernels
        self.pool_kernels_strides = pool_kernels_strides
        self.pool_types = pool_types
        self.num_input_channels = num_input_channels
        self.input_height = input_height
        self.input_width = input_width

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.conv_dims = []
                    (_etype12, _size9) = iprot.readListBegin()
                    for _i13 in range(_size9):
                        _elem14 = iprot.readI32()
                        self.conv_dims.append(_elem14)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.conv_height_kernels = []
                    (_etype18, _size15) = iprot.readListBegin()
                    for _i19 in range(_size15):
                        _elem20 = iprot.readI32()
                        self.conv_height_kernels.append(_elem20)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.conv_width_kernels = []
                    (_etype24, _size21) = iprot.readListBegin()
                    for _i25 in range(_size21):
                        _elem26 = iprot.readI32()
                        self.conv_width_kernels.append(_elem26)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.pool_kernels_strides = []
                    (_etype30, _size27) = iprot.readListBegin()
                    for _i31 in range(_size27):
                        _elem32 = iprot.readI32()
                        self.pool_kernels_strides.append(_elem32)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.LIST:
                    self.pool_types = []
                    (_etype36, _size33) = iprot.readListBegin()
                    for _i37 in range(_size33):
                        _elem38 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.pool_types.append(_elem38)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.I32:
                    self.num_input_channels = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.I32:
                    self.input_height = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.I32:
                    self.input_width = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('CNNParameters')
        if self.conv_dims is not None:
            oprot.writeFieldBegin('conv_dims', TType.LIST, 1)
            oprot.writeListBegin(TType.I32, len(self.conv_dims))
            for iter39 in self.conv_dims:
                oprot.writeI32(iter39)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.conv_height_kernels is not None:
            oprot.writeFieldBegin('conv_height_kernels', TType.LIST, 2)
            oprot.writeListBegin(TType.I32, len(self.conv_height_kernels))
            for iter40 in self.conv_height_kernels:
                oprot.writeI32(iter40)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.conv_width_kernels is not None:
            oprot.writeFieldBegin('conv_width_kernels', TType.LIST, 3)
            oprot.writeListBegin(TType.I32, len(self.conv_width_kernels))
            for iter41 in self.conv_width_kernels:
                oprot.writeI32(iter41)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.pool_kernels_strides is not None:
            oprot.writeFieldBegin('pool_kernels_strides', TType.LIST, 4)
            oprot.writeListBegin(TType.I32, len(self.pool_kernels_strides))
            for iter42 in self.pool_kernels_strides:
                oprot.writeI32(iter42)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.pool_types is not None:
            oprot.writeFieldBegin('pool_types', TType.LIST, 5)
            oprot.writeListBegin(TType.STRING, len(self.pool_types))
            for iter43 in self.pool_types:
                oprot.writeString(iter43.encode('utf-8') if sys.version_info[0] == 2 else iter43)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.num_input_channels is not None:
            oprot.writeFieldBegin('num_input_channels', TType.I32, 6)
            oprot.writeI32(self.num_input_channels)
            oprot.writeFieldEnd()
        if self.input_height is not None:
            oprot.writeFieldBegin('input_height', TType.I32, 7)
            oprot.writeI32(self.input_height)
            oprot.writeFieldEnd()
        if self.input_width is not None:
            oprot.writeFieldBegin('input_width', TType.I32, 8)
            oprot.writeI32(self.input_width)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class FeedForwardParameters(object):
    """
    Attributes:
     - layers
     - activations
    """

    thrift_spec = (
        None,  # 0
        (1, TType.LIST, 'layers', (TType.I32, None, False), [
            256,
            128,
        ], ),  # 1
        (2, TType.LIST, 'activations', (TType.STRING, 'UTF8', False), [
            "relu",
            "relu",
        ], ),  # 2
    )

    def __init__(self, layers=thrift_spec[1][4], activations=thrift_spec[2][4],):
        if layers is self.thrift_spec[1][4]:
            layers = [
                256,
                128,
            ]
        self.layers = layers
        if activations is self.thrift_spec[2][4]:
            activations = [
                "relu",
                "relu",
            ]
        self.activations = activations

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.layers = []
                    (_etype47, _size44) = iprot.readListBegin()
                    for _i48 in range(_size44):
                        _elem49 = iprot.readI32()
                        self.layers.append(_elem49)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.activations = []
                    (_etype53, _size50) = iprot.readListBegin()
                    for _i54 in range(_size50):
                        _elem55 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.activations.append(_elem55)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('FeedForwardParameters')
        if self.layers is not None:
            oprot.writeFieldBegin('layers', TType.LIST, 1)
            oprot.writeListBegin(TType.I32, len(self.layers))
            for iter56 in self.layers:
                oprot.writeI32(iter56)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.activations is not None:
            oprot.writeFieldBegin('activations', TType.LIST, 2)
            oprot.writeListBegin(TType.STRING, len(self.activations))
            for iter57 in self.activations:
                oprot.writeString(iter57.encode('utf-8') if sys.version_info[0] == 2 else iter57)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class FactorizationParameters(object):
    """
    Attributes:
     - state
     - action
    """

    thrift_spec = (
        None,  # 0
        (1, TType.STRUCT, 'state', (FeedForwardParameters, FeedForwardParameters.thrift_spec), None, ),  # 1
        (2, TType.STRUCT, 'action', (FeedForwardParameters, FeedForwardParameters.thrift_spec), None, ),  # 2
    )

    def __init__(self, state=None, action=None,):
        self.state = state
        self.action = action

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.state = FeedForwardParameters()
                    self.state.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.action = FeedForwardParameters()
                    self.action.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('FactorizationParameters')
        if self.state is not None:
            oprot.writeFieldBegin('state', TType.STRUCT, 1)
            self.state.write(oprot)
            oprot.writeFieldEnd()
        if self.action is not None:
            oprot.writeFieldBegin('action', TType.STRUCT, 2)
            self.action.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TrainingParameters(object):
    """
    Attributes:
     - minibatch_size
     - learning_rate
     - optimizer
     - layers
     - activations
     - lr_policy
     - lr_decay
     - dropout_ratio
     - warm_start_model_path
     - cnn_parameters
     - factorization_parameters
     - l2_decay
     - use_noisy_linear_layers
     - weight_init_min_std
     - use_batch_norm
     - clip_grad_norm
    """

    thrift_spec = (
        None,  # 0
        (1, TType.I32, 'minibatch_size', None, 4096, ),  # 1
        (2, TType.DOUBLE, 'learning_rate', None, 0.001, ),  # 2
        (3, TType.STRING, 'optimizer', 'UTF8', "ADAM", ),  # 3
        (4, TType.LIST, 'layers', (TType.I32, None, False), [
            -1,
            256,
            128,
            1,
        ], ),  # 4
        (5, TType.LIST, 'activations', (TType.STRING, 'UTF8', False), [
            "relu",
            "relu",
            "linear",
        ], ),  # 5
        (6, TType.STRING, 'lr_policy', 'UTF8', "fixed", ),  # 6
        (7, TType.DOUBLE, 'lr_decay', None, 0.999, ),  # 7
        (8, TType.DOUBLE, 'dropout_ratio', None, 0, ),  # 8
        (9, TType.STRING, 'warm_start_model_path', 'UTF8', None, ),  # 9
        (10, TType.STRUCT, 'cnn_parameters', (CNNParameters, CNNParameters.thrift_spec), None, ),  # 10
        (11, TType.STRUCT, 'factorization_parameters', (FactorizationParameters, FactorizationParameters.thrift_spec), None, ),  # 11
        (12, TType.DOUBLE, 'l2_decay', None, 0.01, ),  # 12
        (13, TType.BOOL, 'use_noisy_linear_layers', None, False, ),  # 13
        (14, TType.DOUBLE, 'weight_init_min_std', None, 0, ),  # 14
        (15, TType.BOOL, 'use_batch_norm', None, False, ),  # 15
        (16, TType.DOUBLE, 'clip_grad_norm', None, None, ),  # 16
    )

    def __init__(self, minibatch_size=thrift_spec[1][4], learning_rate=thrift_spec[2][4], optimizer=thrift_spec[3][4], layers=thrift_spec[4][4], activations=thrift_spec[5][4], lr_policy=thrift_spec[6][4], lr_decay=thrift_spec[7][4], dropout_ratio=thrift_spec[8][4], warm_start_model_path=None, cnn_parameters=None, factorization_parameters=None, l2_decay=thrift_spec[12][4], use_noisy_linear_layers=thrift_spec[13][4], weight_init_min_std=thrift_spec[14][4], use_batch_norm=thrift_spec[15][4], clip_grad_norm=None,):
        self.minibatch_size = minibatch_size
        self.learning_rate = learning_rate
        self.optimizer = optimizer
        if layers is self.thrift_spec[4][4]:
            layers = [
                -1,
                256,
                128,
                1,
            ]
        self.layers = layers
        if activations is self.thrift_spec[5][4]:
            activations = [
                "relu",
                "relu",
                "linear",
            ]
        self.activations = activations
        self.lr_policy = lr_policy
        self.lr_decay = lr_decay
        self.dropout_ratio = dropout_ratio
        self.warm_start_model_path = warm_start_model_path
        self.cnn_parameters = cnn_parameters
        self.factorization_parameters = factorization_parameters
        self.l2_decay = l2_decay
        self.use_noisy_linear_layers = use_noisy_linear_layers
        self.weight_init_min_std = weight_init_min_std
        self.use_batch_norm = use_batch_norm
        self.clip_grad_norm = clip_grad_norm

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.minibatch_size = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.DOUBLE:
                    self.learning_rate = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.optimizer = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.layers = []
                    (_etype61, _size58) = iprot.readListBegin()
                    for _i62 in range(_size58):
                        _elem63 = iprot.readI32()
                        self.layers.append(_elem63)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.LIST:
                    self.activations = []
                    (_etype67, _size64) = iprot.readListBegin()
                    for _i68 in range(_size64):
                        _elem69 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.activations.append(_elem69)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.lr_policy = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.DOUBLE:
                    self.lr_decay = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.DOUBLE:
                    self.dropout_ratio = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.STRING:
                    self.warm_start_model_path = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 10:
                if ftype == TType.STRUCT:
                    self.cnn_parameters = CNNParameters()
                    self.cnn_parameters.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 11:
                if ftype == TType.STRUCT:
                    self.factorization_parameters = FactorizationParameters()
                    self.factorization_parameters.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 12:
                if ftype == TType.DOUBLE:
                    self.l2_decay = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 13:
                if ftype == TType.BOOL:
                    self.use_noisy_linear_layers = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 14:
                if ftype == TType.DOUBLE:
                    self.weight_init_min_std = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 15:
                if ftype == TType.BOOL:
                    self.use_batch_norm = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 16:
                if ftype == TType.DOUBLE:
                    self.clip_grad_norm = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('TrainingParameters')
        if self.minibatch_size is not None:
            oprot.writeFieldBegin('minibatch_size', TType.I32, 1)
            oprot.writeI32(self.minibatch_size)
            oprot.writeFieldEnd()
        if self.learning_rate is not None:
            oprot.writeFieldBegin('learning_rate', TType.DOUBLE, 2)
            oprot.writeDouble(self.learning_rate)
            oprot.writeFieldEnd()
        if self.optimizer is not None:
            oprot.writeFieldBegin('optimizer', TType.STRING, 3)
            oprot.writeString(self.optimizer.encode('utf-8') if sys.version_info[0] == 2 else self.optimizer)
            oprot.writeFieldEnd()
        if self.layers is not None:
            oprot.writeFieldBegin('layers', TType.LIST, 4)
            oprot.writeListBegin(TType.I32, len(self.layers))
            for iter70 in self.layers:
                oprot.writeI32(iter70)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.activations is not None:
            oprot.writeFieldBegin('activations', TType.LIST, 5)
            oprot.writeListBegin(TType.STRING, len(self.activations))
            for iter71 in self.activations:
                oprot.writeString(iter71.encode('utf-8') if sys.version_info[0] == 2 else iter71)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.lr_policy is not None:
            oprot.writeFieldBegin('lr_policy', TType.STRING, 6)
            oprot.writeString(self.lr_policy.encode('utf-8') if sys.version_info[0] == 2 else self.lr_policy)
            oprot.writeFieldEnd()
        if self.lr_decay is not None:
            oprot.writeFieldBegin('lr_decay', TType.DOUBLE, 7)
            oprot.writeDouble(self.lr_decay)
            oprot.writeFieldEnd()
        if self.dropout_ratio is not None:
            oprot.writeFieldBegin('dropout_ratio', TType.DOUBLE, 8)
            oprot.writeDouble(self.dropout_ratio)
            oprot.writeFieldEnd()
        if self.warm_start_model_path is not None:
            oprot.writeFieldBegin('warm_start_model_path', TType.STRING, 9)
            oprot.writeString(self.warm_start_model_path.encode('utf-8') if sys.version_info[0] == 2 else self.warm_start_model_path)
            oprot.writeFieldEnd()
        if self.cnn_parameters is not None:
            oprot.writeFieldBegin('cnn_parameters', TType.STRUCT, 10)
            self.cnn_parameters.write(oprot)
            oprot.writeFieldEnd()
        if self.factorization_parameters is not None:
            oprot.writeFieldBegin('factorization_parameters', TType.STRUCT, 11)
            self.factorization_parameters.write(oprot)
            oprot.writeFieldEnd()
        if self.l2_decay is not None:
            oprot.writeFieldBegin('l2_decay', TType.DOUBLE, 12)
            oprot.writeDouble(self.l2_decay)
            oprot.writeFieldEnd()
        if self.use_noisy_linear_layers is not None:
            oprot.writeFieldBegin('use_noisy_linear_layers', TType.BOOL, 13)
            oprot.writeBool(self.use_noisy_linear_layers)
            oprot.writeFieldEnd()
        if self.weight_init_min_std is not None:
            oprot.writeFieldBegin('weight_init_min_std', TType.DOUBLE, 14)
            oprot.writeDouble(self.weight_init_min_std)
            oprot.writeFieldEnd()
        if self.use_batch_norm is not None:
            oprot.writeFieldBegin('use_batch_norm', TType.BOOL, 15)
            oprot.writeBool(self.use_batch_norm)
            oprot.writeFieldEnd()
        if self.clip_grad_norm is not None:
            oprot.writeFieldBegin('clip_grad_norm', TType.DOUBLE, 16)
            oprot.writeDouble(self.clip_grad_norm)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class EvaluationParameters(object):
    """
    Attributes:
     - calc_cpe_in_training
    """

    thrift_spec = (
        None,  # 0
        (1, TType.BOOL, 'calc_cpe_in_training', None, True, ),  # 1
    )

    def __init__(self, calc_cpe_in_training=thrift_spec[1][4],):
        self.calc_cpe_in_training = calc_cpe_in_training

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.BOOL:
                    self.calc_cpe_in_training = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('EvaluationParameters')
        if self.calc_cpe_in_training is not None:
            oprot.writeFieldBegin('calc_cpe_in_training', TType.BOOL, 1)
            oprot.writeBool(self.calc_cpe_in_training)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class EvolutionParameters(object):
    """
    Attributes:
     - population_size
     - mutation_power
     - learning_rate
    """

    thrift_spec = (
        None,  # 0
        (1, TType.I32, 'population_size', None, 1000, ),  # 1
        (2, TType.DOUBLE, 'mutation_power', None, 0.1, ),  # 2
        (3, TType.DOUBLE, 'learning_rate', None, 0.01, ),  # 3
    )

    def __init__(self, population_size=thrift_spec[1][4], mutation_power=thrift_spec[2][4], learning_rate=thrift_spec[3][4],):
        self.population_size = population_size
        self.mutation_power = mutation_power
        self.learning_rate = learning_rate

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.population_size = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.DOUBLE:
                    self.mutation_power = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.DOUBLE:
                    self.learning_rate = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('EvolutionParameters')
        if self.population_size is not None:
            oprot.writeFieldBegin('population_size', TType.I32, 1)
            oprot.writeI32(self.population_size)
            oprot.writeFieldEnd()
        if self.mutation_power is not None:
            oprot.writeFieldBegin('mutation_power', TType.DOUBLE, 2)
            oprot.writeDouble(self.mutation_power)
            oprot.writeFieldEnd()
        if self.learning_rate is not None:
            oprot.writeFieldBegin('learning_rate', TType.DOUBLE, 3)
            oprot.writeDouble(self.learning_rate)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class StateFeatureParameters(object):
    """
    Attributes:
     - state_feature_names_override
     - state_feature_hashes_override
    """

    thrift_spec = (
        None,  # 0
        (1, TType.LIST, 'state_feature_names_override', (TType.STRING, 'UTF8', False), [
        ], ),  # 1
        (2, TType.LIST, 'state_feature_hashes_override', (TType.I32, None, False), [
        ], ),  # 2
    )

    def __init__(self, state_feature_names_override=thrift_spec[1][4], state_feature_hashes_override=thrift_spec[2][4],):
        if state_feature_names_override is self.thrift_spec[1][4]:
            state_feature_names_override = [
            ]
        self.state_feature_names_override = state_feature_names_override
        if state_feature_hashes_override is self.thrift_spec[2][4]:
            state_feature_hashes_override = [
            ]
        self.state_feature_hashes_override = state_feature_hashes_override

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.state_feature_names_override = []
                    (_etype75, _size72) = iprot.readListBegin()
                    for _i76 in range(_size72):
                        _elem77 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.state_feature_names_override.append(_elem77)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.state_feature_hashes_override = []
                    (_etype81, _size78) = iprot.readListBegin()
                    for _i82 in range(_size78):
                        _elem83 = iprot.readI32()
                        self.state_feature_hashes_override.append(_elem83)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('StateFeatureParameters')
        if self.state_feature_names_override is not None:
            oprot.writeFieldBegin('state_feature_names_override', TType.LIST, 1)
            oprot.writeListBegin(TType.STRING, len(self.state_feature_names_override))
            for iter84 in self.state_feature_names_override:
                oprot.writeString(iter84.encode('utf-8') if sys.version_info[0] == 2 else iter84)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.state_feature_hashes_override is not None:
            oprot.writeFieldBegin('state_feature_hashes_override', TType.LIST, 2)
            oprot.writeListBegin(TType.I32, len(self.state_feature_hashes_override))
            for iter85 in self.state_feature_hashes_override:
                oprot.writeI32(iter85)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class DiscreteActionModelParameters(object):
    """
    Attributes:
     - actions
     - rl
     - training
     - rainbow
     - state_feature_params
     - target_action_distribution
     - evaluation
    """

    thrift_spec = (
        None,  # 0
        (1, TType.LIST, 'actions', (TType.STRING, 'UTF8', False), None, ),  # 1
        (2, TType.STRUCT, 'rl', (RLParameters, RLParameters.thrift_spec), None, ),  # 2
        (3, TType.STRUCT, 'training', (TrainingParameters, TrainingParameters.thrift_spec), None, ),  # 3
        None,  # 4
        (5, TType.STRUCT, 'rainbow', (RainbowDQNParameters, RainbowDQNParameters.thrift_spec), None, ),  # 5
        None,  # 6
        (7, TType.STRUCT, 'state_feature_params', (StateFeatureParameters, StateFeatureParameters.thrift_spec), None, ),  # 7
        (8, TType.LIST, 'target_action_distribution', (TType.DOUBLE, None, False), None, ),  # 8
        None,  # 9
        None,  # 10
        (11, TType.STRUCT, 'evaluation', (EvaluationParameters, EvaluationParameters.thrift_spec), EvaluationParameters(**{
        }), ),  # 11
    )

    def __init__(self, actions=None, rl=None, training=None, rainbow=None, state_feature_params=None, target_action_distribution=None, evaluation=thrift_spec[11][4],):
        self.actions = actions
        self.rl = rl
        self.training = training
        self.rainbow = rainbow
        self.state_feature_params = state_feature_params
        self.target_action_distribution = target_action_distribution
        if evaluation is self.thrift_spec[11][4]:
            evaluation = EvaluationParameters(**{
            })
        self.evaluation = evaluation

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.actions = []
                    (_etype89, _size86) = iprot.readListBegin()
                    for _i90 in range(_size86):
                        _elem91 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.actions.append(_elem91)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.rl = RLParameters()
                    self.rl.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.training = TrainingParameters()
                    self.training.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.rainbow = RainbowDQNParameters()
                    self.rainbow.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.STRUCT:
                    self.state_feature_params = StateFeatureParameters()
                    self.state_feature_params.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.LIST:
                    self.target_action_distribution = []
                    (_etype95, _size92) = iprot.readListBegin()
                    for _i96 in range(_size92):
                        _elem97 = iprot.readDouble()
                        self.target_action_distribution.append(_elem97)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 11:
                if ftype == TType.STRUCT:
                    self.evaluation = EvaluationParameters()
                    self.evaluation.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('DiscreteActionModelParameters')
        if self.actions is not None:
            oprot.writeFieldBegin('actions', TType.LIST, 1)
            oprot.writeListBegin(TType.STRING, len(self.actions))
            for iter98 in self.actions:
                oprot.writeString(iter98.encode('utf-8') if sys.version_info[0] == 2 else iter98)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.rl is not None:
            oprot.writeFieldBegin('rl', TType.STRUCT, 2)
            self.rl.write(oprot)
            oprot.writeFieldEnd()
        if self.training is not None:
            oprot.writeFieldBegin('training', TType.STRUCT, 3)
            self.training.write(oprot)
            oprot.writeFieldEnd()
        if self.rainbow is not None:
            oprot.writeFieldBegin('rainbow', TType.STRUCT, 5)
            self.rainbow.write(oprot)
            oprot.writeFieldEnd()
        if self.state_feature_params is not None:
            oprot.writeFieldBegin('state_feature_params', TType.STRUCT, 7)
            self.state_feature_params.write(oprot)
            oprot.writeFieldEnd()
        if self.target_action_distribution is not None:
            oprot.writeFieldBegin('target_action_distribution', TType.LIST, 8)
            oprot.writeListBegin(TType.DOUBLE, len(self.target_action_distribution))
            for iter99 in self.target_action_distribution:
                oprot.writeDouble(iter99)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.evaluation is not None:
            oprot.writeFieldBegin('evaluation', TType.STRUCT, 11)
            self.evaluation.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class ContinuousActionModelParameters(object):
    """
    Attributes:
     - rl
     - training
     - rainbow
     - evaluation
     - state_feature_params
    """

    thrift_spec = (
        None,  # 0
        (1, TType.STRUCT, 'rl', (RLParameters, RLParameters.thrift_spec), None, ),  # 1
        (2, TType.STRUCT, 'training', (TrainingParameters, TrainingParameters.thrift_spec), None, ),  # 2
        None,  # 3
        (4, TType.STRUCT, 'rainbow', (RainbowDQNParameters, RainbowDQNParameters.thrift_spec), None, ),  # 4
        None,  # 5
        (6, TType.STRUCT, 'evaluation', (EvaluationParameters, EvaluationParameters.thrift_spec), EvaluationParameters(**{
        }), ),  # 6
        (7, TType.STRUCT, 'state_feature_params', (StateFeatureParameters, StateFeatureParameters.thrift_spec), None, ),  # 7
    )

    def __init__(self, rl=None, training=None, rainbow=None, evaluation=thrift_spec[6][4], state_feature_params=None,):
        self.rl = rl
        self.training = training
        self.rainbow = rainbow
        if evaluation is self.thrift_spec[6][4]:
            evaluation = EvaluationParameters(**{
            })
        self.evaluation = evaluation
        self.state_feature_params = state_feature_params

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.rl = RLParameters()
                    self.rl.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.training = TrainingParameters()
                    self.training.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.rainbow = RainbowDQNParameters()
                    self.rainbow.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRUCT:
                    self.evaluation = EvaluationParameters()
                    self.evaluation.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.STRUCT:
                    self.state_feature_params = StateFeatureParameters()
                    self.state_feature_params.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('ContinuousActionModelParameters')
        if self.rl is not None:
            oprot.writeFieldBegin('rl', TType.STRUCT, 1)
            self.rl.write(oprot)
            oprot.writeFieldEnd()
        if self.training is not None:
            oprot.writeFieldBegin('training', TType.STRUCT, 2)
            self.training.write(oprot)
            oprot.writeFieldEnd()
        if self.rainbow is not None:
            oprot.writeFieldBegin('rainbow', TType.STRUCT, 4)
            self.rainbow.write(oprot)
            oprot.writeFieldEnd()
        if self.evaluation is not None:
            oprot.writeFieldBegin('evaluation', TType.STRUCT, 6)
            self.evaluation.write(oprot)
            oprot.writeFieldEnd()
        if self.state_feature_params is not None:
            oprot.writeFieldBegin('state_feature_params', TType.STRUCT, 7)
            self.state_feature_params.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class DDPGNetworkParameters(object):
    """
    Attributes:
     - layers
     - activations
     - l2_decay
     - learning_rate
    """

    thrift_spec = (
        None,  # 0
        (1, TType.LIST, 'layers', (TType.I32, None, False), [
            -1,
            256,
            128,
            1,
        ], ),  # 1
        (2, TType.LIST, 'activations', (TType.STRING, 'UTF8', False), [
            "relu",
            "relu",
            "tanh",
        ], ),  # 2
        (3, TType.DOUBLE, 'l2_decay', None, 0.01, ),  # 3
        (4, TType.DOUBLE, 'learning_rate', None, 0.001, ),  # 4
    )

    def __init__(self, layers=thrift_spec[1][4], activations=thrift_spec[2][4], l2_decay=thrift_spec[3][4], learning_rate=thrift_spec[4][4],):
        if layers is self.thrift_spec[1][4]:
            layers = [
                -1,
                256,
                128,
                1,
            ]
        self.layers = layers
        if activations is self.thrift_spec[2][4]:
            activations = [
                "relu",
                "relu",
                "tanh",
            ]
        self.activations = activations
        self.l2_decay = l2_decay
        self.learning_rate = learning_rate

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.layers = []
                    (_etype103, _size100) = iprot.readListBegin()
                    for _i104 in range(_size100):
                        _elem105 = iprot.readI32()
                        self.layers.append(_elem105)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.activations = []
                    (_etype109, _size106) = iprot.readListBegin()
                    for _i110 in range(_size106):
                        _elem111 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.activations.append(_elem111)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.DOUBLE:
                    self.l2_decay = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.DOUBLE:
                    self.learning_rate = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('DDPGNetworkParameters')
        if self.layers is not None:
            oprot.writeFieldBegin('layers', TType.LIST, 1)
            oprot.writeListBegin(TType.I32, len(self.layers))
            for iter112 in self.layers:
                oprot.writeI32(iter112)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.activations is not None:
            oprot.writeFieldBegin('activations', TType.LIST, 2)
            oprot.writeListBegin(TType.STRING, len(self.activations))
            for iter113 in self.activations:
                oprot.writeString(iter113.encode('utf-8') if sys.version_info[0] == 2 else iter113)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.l2_decay is not None:
            oprot.writeFieldBegin('l2_decay', TType.DOUBLE, 3)
            oprot.writeDouble(self.l2_decay)
            oprot.writeFieldEnd()
        if self.learning_rate is not None:
            oprot.writeFieldBegin('learning_rate', TType.DOUBLE, 4)
            oprot.writeDouble(self.learning_rate)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class DDPGTrainingParameters(object):
    """
    Attributes:
     - minibatch_size
     - final_layer_init
     - optimizer
     - warm_start_model_path
     - use_noisy_linear_layers
    """

    thrift_spec = (
        None,  # 0
        (1, TType.I32, 'minibatch_size', None, 2048, ),  # 1
        (2, TType.DOUBLE, 'final_layer_init', None, 0.003, ),  # 2
        (3, TType.STRING, 'optimizer', 'UTF8', "ADAM", ),  # 3
        (4, TType.STRING, 'warm_start_model_path', 'UTF8', None, ),  # 4
        (5, TType.BOOL, 'use_noisy_linear_layers', None, False, ),  # 5
    )

    def __init__(self, minibatch_size=thrift_spec[1][4], final_layer_init=thrift_spec[2][4], optimizer=thrift_spec[3][4], warm_start_model_path=None, use_noisy_linear_layers=thrift_spec[5][4],):
        self.minibatch_size = minibatch_size
        self.final_layer_init = final_layer_init
        self.optimizer = optimizer
        self.warm_start_model_path = warm_start_model_path
        self.use_noisy_linear_layers = use_noisy_linear_layers

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.minibatch_size = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.DOUBLE:
                    self.final_layer_init = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.optimizer = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.warm_start_model_path = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.BOOL:
                    self.use_noisy_linear_layers = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('DDPGTrainingParameters')
        if self.minibatch_size is not None:
            oprot.writeFieldBegin('minibatch_size', TType.I32, 1)
            oprot.writeI32(self.minibatch_size)
            oprot.writeFieldEnd()
        if self.final_layer_init is not None:
            oprot.writeFieldBegin('final_layer_init', TType.DOUBLE, 2)
            oprot.writeDouble(self.final_layer_init)
            oprot.writeFieldEnd()
        if self.optimizer is not None:
            oprot.writeFieldBegin('optimizer', TType.STRING, 3)
            oprot.writeString(self.optimizer.encode('utf-8') if sys.version_info[0] == 2 else self.optimizer)
            oprot.writeFieldEnd()
        if self.warm_start_model_path is not None:
            oprot.writeFieldBegin('warm_start_model_path', TType.STRING, 4)
            oprot.writeString(self.warm_start_model_path.encode('utf-8') if sys.version_info[0] == 2 else self.warm_start_model_path)
            oprot.writeFieldEnd()
        if self.use_noisy_linear_layers is not None:
            oprot.writeFieldBegin('use_noisy_linear_layers', TType.BOOL, 5)
            oprot.writeBool(self.use_noisy_linear_layers)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class DDPGModelParameters(object):
    """
    Attributes:
     - rl
     - shared_training
     - actor_training
     - critic_training
     - action_rescale_map
     - state_feature_params
     - evaluation
    """

    thrift_spec = (
        None,  # 0
        (1, TType.STRUCT, 'rl', (RLParameters, RLParameters.thrift_spec), None, ),  # 1
        (2, TType.STRUCT, 'shared_training', (DDPGTrainingParameters, DDPGTrainingParameters.thrift_spec), None, ),  # 2
        (3, TType.STRUCT, 'actor_training', (DDPGNetworkParameters, DDPGNetworkParameters.thrift_spec), None, ),  # 3
        (4, TType.STRUCT, 'critic_training', (DDPGNetworkParameters, DDPGNetworkParameters.thrift_spec), None, ),  # 4
        (5, TType.MAP, 'action_rescale_map', (TType.I64, None, TType.LIST, (TType.DOUBLE, None, False), False), {
        }, ),  # 5
        (6, TType.STRUCT, 'state_feature_params', (StateFeatureParameters, StateFeatureParameters.thrift_spec), None, ),  # 6
        (7, TType.STRUCT, 'evaluation', (EvaluationParameters, EvaluationParameters.thrift_spec), EvaluationParameters(**{
        }), ),  # 7
    )

    def __init__(self, rl=None, shared_training=None, actor_training=None, critic_training=None, action_rescale_map=thrift_spec[5][4], state_feature_params=None, evaluation=thrift_spec[7][4],):
        self.rl = rl
        self.shared_training = shared_training
        self.actor_training = actor_training
        self.critic_training = critic_training
        if action_rescale_map is self.thrift_spec[5][4]:
            action_rescale_map = {
            }
        self.action_rescale_map = action_rescale_map
        self.state_feature_params = state_feature_params
        if evaluation is self.thrift_spec[7][4]:
            evaluation = EvaluationParameters(**{
            })
        self.evaluation = evaluation

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.rl = RLParameters()
                    self.rl.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.shared_training = DDPGTrainingParameters()
                    self.shared_training.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.actor_training = DDPGNetworkParameters()
                    self.actor_training.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.critic_training = DDPGNetworkParameters()
                    self.critic_training.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.MAP:
                    self.action_rescale_map = {}
                    (_ktype115, _vtype116, _size114) = iprot.readMapBegin()
                    for _i118 in range(_size114):
                        _key119 = iprot.readI64()
                        _val120 = []
                        (_etype124, _size121) = iprot.readListBegin()
                        for _i125 in range(_size121):
                            _elem126 = iprot.readDouble()
                            _val120.append(_elem126)
                        iprot.readListEnd()
                        self.action_rescale_map[_key119] = _val120
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRUCT:
                    self.state_feature_params = StateFeatureParameters()
                    self.state_feature_params.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.STRUCT:
                    self.evaluation = EvaluationParameters()
                    self.evaluation.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('DDPGModelParameters')
        if self.rl is not None:
            oprot.writeFieldBegin('rl', TType.STRUCT, 1)
            self.rl.write(oprot)
            oprot.writeFieldEnd()
        if self.shared_training is not None:
            oprot.writeFieldBegin('shared_training', TType.STRUCT, 2)
            self.shared_training.write(oprot)
            oprot.writeFieldEnd()
        if self.actor_training is not None:
            oprot.writeFieldBegin('actor_training', TType.STRUCT, 3)
            self.actor_training.write(oprot)
            oprot.writeFieldEnd()
        if self.critic_training is not None:
            oprot.writeFieldBegin('critic_training', TType.STRUCT, 4)
            self.critic_training.write(oprot)
            oprot.writeFieldEnd()
        if self.action_rescale_map is not None:
            oprot.writeFieldBegin('action_rescale_map', TType.MAP, 5)
            oprot.writeMapBegin(TType.I64, TType.LIST, len(self.action_rescale_map))
            for kiter127, viter128 in self.action_rescale_map.items():
                oprot.writeI64(kiter127)
                oprot.writeListBegin(TType.DOUBLE, len(viter128))
                for iter129 in viter128:
                    oprot.writeDouble(iter129)
                oprot.writeListEnd()
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.state_feature_params is not None:
            oprot.writeFieldBegin('state_feature_params', TType.STRUCT, 6)
            self.state_feature_params.write(oprot)
            oprot.writeFieldEnd()
        if self.evaluation is not None:
            oprot.writeFieldBegin('evaluation', TType.STRUCT, 7)
            self.evaluation.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class OptimizerParameters(object):
    """
    Attributes:
     - optimizer
     - learning_rate
     - l2_decay
    """

    thrift_spec = (
        None,  # 0
        (1, TType.STRING, 'optimizer', 'UTF8', "ADAM", ),  # 1
        (2, TType.DOUBLE, 'learning_rate', None, 0.001, ),  # 2
        (3, TType.DOUBLE, 'l2_decay', None, 0.01, ),  # 3
    )

    def __init__(self, optimizer=thrift_spec[1][4], learning_rate=thrift_spec[2][4], l2_decay=thrift_spec[3][4],):
        self.optimizer = optimizer
        self.learning_rate = learning_rate
        self.l2_decay = l2_decay

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.optimizer = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.DOUBLE:
                    self.learning_rate = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.DOUBLE:
                    self.l2_decay = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('OptimizerParameters')
        if self.optimizer is not None:
            oprot.writeFieldBegin('optimizer', TType.STRING, 1)
            oprot.writeString(self.optimizer.encode('utf-8') if sys.version_info[0] == 2 else self.optimizer)
            oprot.writeFieldEnd()
        if self.learning_rate is not None:
            oprot.writeFieldBegin('learning_rate', TType.DOUBLE, 2)
            oprot.writeDouble(self.learning_rate)
            oprot.writeFieldEnd()
        if self.l2_decay is not None:
            oprot.writeFieldBegin('l2_decay', TType.DOUBLE, 3)
            oprot.writeDouble(self.l2_decay)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class SACTrainingParameters(object):
    """
    Attributes:
     - minibatch_size
     - q_network_optimizer
     - value_network_optimizer
     - actor_network_optimizer
     - use_2_q_functions
     - entropy_temperature
     - warm_start_model_path
     - logged_action_uniform_prior
    """

    thrift_spec = (
        None,  # 0
        (1, TType.I32, 'minibatch_size', None, 1024, ),  # 1
        (2, TType.STRUCT, 'q_network_optimizer', (OptimizerParameters, OptimizerParameters.thrift_spec), OptimizerParameters(**{
        }), ),  # 2
        (3, TType.STRUCT, 'value_network_optimizer', (OptimizerParameters, OptimizerParameters.thrift_spec), OptimizerParameters(**{
        }), ),  # 3
        (4, TType.STRUCT, 'actor_network_optimizer', (OptimizerParameters, OptimizerParameters.thrift_spec), OptimizerParameters(**{
        }), ),  # 4
        (5, TType.BOOL, 'use_2_q_functions', None, True, ),  # 5
        (6, TType.DOUBLE, 'entropy_temperature', None, 0.1, ),  # 6
        (7, TType.STRING, 'warm_start_model_path', 'UTF8', None, ),  # 7
        (8, TType.BOOL, 'logged_action_uniform_prior', None, True, ),  # 8
    )

    def __init__(self, minibatch_size=thrift_spec[1][4], q_network_optimizer=thrift_spec[2][4], value_network_optimizer=thrift_spec[3][4], actor_network_optimizer=thrift_spec[4][4], use_2_q_functions=thrift_spec[5][4], entropy_temperature=thrift_spec[6][4], warm_start_model_path=None, logged_action_uniform_prior=thrift_spec[8][4],):
        self.minibatch_size = minibatch_size
        if q_network_optimizer is self.thrift_spec[2][4]:
            q_network_optimizer = OptimizerParameters(**{
            })
        self.q_network_optimizer = q_network_optimizer
        if value_network_optimizer is self.thrift_spec[3][4]:
            value_network_optimizer = OptimizerParameters(**{
            })
        self.value_network_optimizer = value_network_optimizer
        if actor_network_optimizer is self.thrift_spec[4][4]:
            actor_network_optimizer = OptimizerParameters(**{
            })
        self.actor_network_optimizer = actor_network_optimizer
        self.use_2_q_functions = use_2_q_functions
        self.entropy_temperature = entropy_temperature
        self.warm_start_model_path = warm_start_model_path
        self.logged_action_uniform_prior = logged_action_uniform_prior

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.minibatch_size = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.q_network_optimizer = OptimizerParameters()
                    self.q_network_optimizer.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.value_network_optimizer = OptimizerParameters()
                    self.value_network_optimizer.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.actor_network_optimizer = OptimizerParameters()
                    self.actor_network_optimizer.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.BOOL:
                    self.use_2_q_functions = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.DOUBLE:
                    self.entropy_temperature = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.STRING:
                    self.warm_start_model_path = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.BOOL:
                    self.logged_action_uniform_prior = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('SACTrainingParameters')
        if self.minibatch_size is not None:
            oprot.writeFieldBegin('minibatch_size', TType.I32, 1)
            oprot.writeI32(self.minibatch_size)
            oprot.writeFieldEnd()
        if self.q_network_optimizer is not None:
            oprot.writeFieldBegin('q_network_optimizer', TType.STRUCT, 2)
            self.q_network_optimizer.write(oprot)
            oprot.writeFieldEnd()
        if self.value_network_optimizer is not None:
            oprot.writeFieldBegin('value_network_optimizer', TType.STRUCT, 3)
            self.value_network_optimizer.write(oprot)
            oprot.writeFieldEnd()
        if self.actor_network_optimizer is not None:
            oprot.writeFieldBegin('actor_network_optimizer', TType.STRUCT, 4)
            self.actor_network_optimizer.write(oprot)
            oprot.writeFieldEnd()
        if self.use_2_q_functions is not None:
            oprot.writeFieldBegin('use_2_q_functions', TType.BOOL, 5)
            oprot.writeBool(self.use_2_q_functions)
            oprot.writeFieldEnd()
        if self.entropy_temperature is not None:
            oprot.writeFieldBegin('entropy_temperature', TType.DOUBLE, 6)
            oprot.writeDouble(self.entropy_temperature)
            oprot.writeFieldEnd()
        if self.warm_start_model_path is not None:
            oprot.writeFieldBegin('warm_start_model_path', TType.STRING, 7)
            oprot.writeString(self.warm_start_model_path.encode('utf-8') if sys.version_info[0] == 2 else self.warm_start_model_path)
            oprot.writeFieldEnd()
        if self.logged_action_uniform_prior is not None:
            oprot.writeFieldBegin('logged_action_uniform_prior', TType.BOOL, 8)
            oprot.writeBool(self.logged_action_uniform_prior)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class SACModelParameters(object):
    """
    Attributes:
     - rl
     - training
     - q_network
     - value_network
     - actor_network
     - state_feature_params
     - evaluation
    """

    thrift_spec = (
        None,  # 0
        (1, TType.STRUCT, 'rl', (RLParameters, RLParameters.thrift_spec), RLParameters(**{
            "reward_burnin": 100,
            "maxq_learning": False,
            "tensorboard_logging_freq": 100,
        }), ),  # 1
        (2, TType.STRUCT, 'training', (SACTrainingParameters, SACTrainingParameters.thrift_spec), SACTrainingParameters(**{
        }), ),  # 2
        (3, TType.STRUCT, 'q_network', (FeedForwardParameters, FeedForwardParameters.thrift_spec), FeedForwardParameters(**{
        }), ),  # 3
        (4, TType.STRUCT, 'value_network', (FeedForwardParameters, FeedForwardParameters.thrift_spec), FeedForwardParameters(**{
        }), ),  # 4
        (5, TType.STRUCT, 'actor_network', (FeedForwardParameters, FeedForwardParameters.thrift_spec), FeedForwardParameters(**{
        }), ),  # 5
        None,  # 6
        None,  # 7
        (8, TType.STRUCT, 'state_feature_params', (StateFeatureParameters, StateFeatureParameters.thrift_spec), None, ),  # 8
        (9, TType.STRUCT, 'evaluation', (EvaluationParameters, EvaluationParameters.thrift_spec), EvaluationParameters(**{
        }), ),  # 9
    )

    def __init__(self, rl=thrift_spec[1][4], training=thrift_spec[2][4], q_network=thrift_spec[3][4], value_network=thrift_spec[4][4], actor_network=thrift_spec[5][4], state_feature_params=None, evaluation=thrift_spec[9][4],):
        if rl is self.thrift_spec[1][4]:
            rl = RLParameters(**{
                "reward_burnin": 100,
                "maxq_learning": False,
                "tensorboard_logging_freq": 100,
            })
        self.rl = rl
        if training is self.thrift_spec[2][4]:
            training = SACTrainingParameters(**{
            })
        self.training = training
        if q_network is self.thrift_spec[3][4]:
            q_network = FeedForwardParameters(**{
            })
        self.q_network = q_network
        if value_network is self.thrift_spec[4][4]:
            value_network = FeedForwardParameters(**{
            })
        self.value_network = value_network
        if actor_network is self.thrift_spec[5][4]:
            actor_network = FeedForwardParameters(**{
            })
        self.actor_network = actor_network
        self.state_feature_params = state_feature_params
        if evaluation is self.thrift_spec[9][4]:
            evaluation = EvaluationParameters(**{
            })
        self.evaluation = evaluation

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.rl = RLParameters()
                    self.rl.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.training = SACTrainingParameters()
                    self.training.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.q_network = FeedForwardParameters()
                    self.q_network.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.value_network = FeedForwardParameters()
                    self.value_network.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.actor_network = FeedForwardParameters()
                    self.actor_network.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.STRUCT:
                    self.state_feature_params = StateFeatureParameters()
                    self.state_feature_params.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.STRUCT:
                    self.evaluation = EvaluationParameters()
                    self.evaluation.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('SACModelParameters')
        if self.rl is not None:
            oprot.writeFieldBegin('rl', TType.STRUCT, 1)
            self.rl.write(oprot)
            oprot.writeFieldEnd()
        if self.training is not None:
            oprot.writeFieldBegin('training', TType.STRUCT, 2)
            self.training.write(oprot)
            oprot.writeFieldEnd()
        if self.q_network is not None:
            oprot.writeFieldBegin('q_network', TType.STRUCT, 3)
            self.q_network.write(oprot)
            oprot.writeFieldEnd()
        if self.value_network is not None:
            oprot.writeFieldBegin('value_network', TType.STRUCT, 4)
            self.value_network.write(oprot)
            oprot.writeFieldEnd()
        if self.actor_network is not None:
            oprot.writeFieldBegin('actor_network', TType.STRUCT, 5)
            self.actor_network.write(oprot)
            oprot.writeFieldEnd()
        if self.state_feature_params is not None:
            oprot.writeFieldBegin('state_feature_params', TType.STRUCT, 8)
            self.state_feature_params.write(oprot)
            oprot.writeFieldEnd()
        if self.evaluation is not None:
            oprot.writeFieldBegin('evaluation', TType.STRUCT, 9)
            self.evaluation.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class KNNDQNModelParameters(object):
    """
    Attributes:
     - rl
     - shared_training
     - actor_training
     - critic_training
     - num_actions
     - action_dim
     - k
     - evaluation
    """

    thrift_spec = (
        None,  # 0
        (1, TType.STRUCT, 'rl', (RLParameters, RLParameters.thrift_spec), None, ),  # 1
        (2, TType.STRUCT, 'shared_training', (DDPGTrainingParameters, DDPGTrainingParameters.thrift_spec), None, ),  # 2
        (3, TType.STRUCT, 'actor_training', (DDPGNetworkParameters, DDPGNetworkParameters.thrift_spec), None, ),  # 3
        (4, TType.STRUCT, 'critic_training', (DDPGNetworkParameters, DDPGNetworkParameters.thrift_spec), None, ),  # 4
        (5, TType.I64, 'num_actions', None, None, ),  # 5
        (6, TType.I32, 'action_dim', None, None, ),  # 6
        (7, TType.I64, 'k', None, None, ),  # 7
        (8, TType.STRUCT, 'evaluation', (EvaluationParameters, EvaluationParameters.thrift_spec), EvaluationParameters(**{
        }), ),  # 8
    )

    def __init__(self, rl=None, shared_training=None, actor_training=None, critic_training=None, num_actions=None, action_dim=None, k=None, evaluation=thrift_spec[8][4],):
        self.rl = rl
        self.shared_training = shared_training
        self.actor_training = actor_training
        self.critic_training = critic_training
        self.num_actions = num_actions
        self.action_dim = action_dim
        self.k = k
        if evaluation is self.thrift_spec[8][4]:
            evaluation = EvaluationParameters(**{
            })
        self.evaluation = evaluation

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.rl = RLParameters()
                    self.rl.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.shared_training = DDPGTrainingParameters()
                    self.shared_training.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.actor_training = DDPGNetworkParameters()
                    self.actor_training.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.critic_training = DDPGNetworkParameters()
                    self.critic_training.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I64:
                    self.num_actions = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.I32:
                    self.action_dim = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.I64:
                    self.k = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.STRUCT:
                    self.evaluation = EvaluationParameters()
                    self.evaluation.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('KNNDQNModelParameters')
        if self.rl is not None:
            oprot.writeFieldBegin('rl', TType.STRUCT, 1)
            self.rl.write(oprot)
            oprot.writeFieldEnd()
        if self.shared_training is not None:
            oprot.writeFieldBegin('shared_training', TType.STRUCT, 2)
            self.shared_training.write(oprot)
            oprot.writeFieldEnd()
        if self.actor_training is not None:
            oprot.writeFieldBegin('actor_training', TType.STRUCT, 3)
            self.actor_training.write(oprot)
            oprot.writeFieldEnd()
        if self.critic_training is not None:
            oprot.writeFieldBegin('critic_training', TType.STRUCT, 4)
            self.critic_training.write(oprot)
            oprot.writeFieldEnd()
        if self.num_actions is not None:
            oprot.writeFieldBegin('num_actions', TType.I64, 5)
            oprot.writeI64(self.num_actions)
            oprot.writeFieldEnd()
        if self.action_dim is not None:
            oprot.writeFieldBegin('action_dim', TType.I32, 6)
            oprot.writeI32(self.action_dim)
            oprot.writeFieldEnd()
        if self.k is not None:
            oprot.writeFieldBegin('k', TType.I64, 7)
            oprot.writeI64(self.k)
            oprot.writeFieldEnd()
        if self.evaluation is not None:
            oprot.writeFieldBegin('evaluation', TType.STRUCT, 8)
            self.evaluation.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class OpenAIGymParameters(object):
    """
    Attributes:
     - num_episodes
     - max_steps
     - train_every_ts
     - train_after_ts
     - test_every_ts
     - test_after_ts
     - num_train_batches
     - avg_over_num_episodes
     - offline_train_epochs
     - epsilon_decay
     - minimum_epsilon
     - solved_reward_threshold
     - max_episodes_to_run_after_solved
     - stop_training_after_solved
    """

    thrift_spec = (
        None,  # 0
        (1, TType.I32, 'num_episodes', None, 1000, ),  # 1
        (2, TType.I32, 'max_steps', None, 200, ),  # 2
        (3, TType.I32, 'train_every_ts', None, 1, ),  # 3
        (4, TType.I32, 'train_after_ts', None, 1, ),  # 4
        (5, TType.I32, 'test_every_ts', None, 2000, ),  # 5
        (6, TType.I32, 'test_after_ts', None, 1, ),  # 6
        (7, TType.I32, 'num_train_batches', None, 1, ),  # 7
        (8, TType.I32, 'avg_over_num_episodes', None, 100, ),  # 8
        (9, TType.I32, 'offline_train_epochs', None, 30, ),  # 9
        (10, TType.DOUBLE, 'epsilon_decay', None, 1, ),  # 10
        (11, TType.DOUBLE, 'minimum_epsilon', None, None, ),  # 11
        (12, TType.I32, 'solved_reward_threshold', None, None, ),  # 12
        (13, TType.I32, 'max_episodes_to_run_after_solved', None, None, ),  # 13
        (14, TType.BOOL, 'stop_training_after_solved', None, None, ),  # 14
    )

    def __init__(self, num_episodes=thrift_spec[1][4], max_steps=thrift_spec[2][4], train_every_ts=thrift_spec[3][4], train_after_ts=thrift_spec[4][4], test_every_ts=thrift_spec[5][4], test_after_ts=thrift_spec[6][4], num_train_batches=thrift_spec[7][4], avg_over_num_episodes=thrift_spec[8][4], offline_train_epochs=thrift_spec[9][4], epsilon_decay=thrift_spec[10][4], minimum_epsilon=None, solved_reward_threshold=None, max_episodes_to_run_after_solved=None, stop_training_after_solved=None,):
        self.num_episodes = num_episodes
        self.max_steps = max_steps
        self.train_every_ts = train_every_ts
        self.train_after_ts = train_after_ts
        self.test_every_ts = test_every_ts
        self.test_after_ts = test_after_ts
        self.num_train_batches = num_train_batches
        self.avg_over_num_episodes = avg_over_num_episodes
        self.offline_train_epochs = offline_train_epochs
        self.epsilon_decay = epsilon_decay
        self.minimum_epsilon = minimum_epsilon
        self.solved_reward_threshold = solved_reward_threshold
        self.max_episodes_to_run_after_solved = max_episodes_to_run_after_solved
        self.stop_training_after_solved = stop_training_after_solved

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.num_episodes = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.max_steps = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.train_every_ts = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.train_after_ts = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I32:
                    self.test_every_ts = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.I32:
                    self.test_after_ts = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.I32:
                    self.num_train_batches = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.I32:
                    self.avg_over_num_episodes = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.I32:
                    self.offline_train_epochs = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 10:
                if ftype == TType.DOUBLE:
                    self.epsilon_decay = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 11:
                if ftype == TType.DOUBLE:
                    self.minimum_epsilon = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 12:
                if ftype == TType.I32:
                    self.solved_reward_threshold = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 13:
                if ftype == TType.I32:
                    self.max_episodes_to_run_after_solved = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 14:
                if ftype == TType.BOOL:
                    self.stop_training_after_solved = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('OpenAIGymParameters')
        if self.num_episodes is not None:
            oprot.writeFieldBegin('num_episodes', TType.I32, 1)
            oprot.writeI32(self.num_episodes)
            oprot.writeFieldEnd()
        if self.max_steps is not None:
            oprot.writeFieldBegin('max_steps', TType.I32, 2)
            oprot.writeI32(self.max_steps)
            oprot.writeFieldEnd()
        if self.train_every_ts is not None:
            oprot.writeFieldBegin('train_every_ts', TType.I32, 3)
            oprot.writeI32(self.train_every_ts)
            oprot.writeFieldEnd()
        if self.train_after_ts is not None:
            oprot.writeFieldBegin('train_after_ts', TType.I32, 4)
            oprot.writeI32(self.train_after_ts)
            oprot.writeFieldEnd()
        if self.test_every_ts is not None:
            oprot.writeFieldBegin('test_every_ts', TType.I32, 5)
            oprot.writeI32(self.test_every_ts)
            oprot.writeFieldEnd()
        if self.test_after_ts is not None:
            oprot.writeFieldBegin('test_after_ts', TType.I32, 6)
            oprot.writeI32(self.test_after_ts)
            oprot.writeFieldEnd()
        if self.num_train_batches is not None:
            oprot.writeFieldBegin('num_train_batches', TType.I32, 7)
            oprot.writeI32(self.num_train_batches)
            oprot.writeFieldEnd()
        if self.avg_over_num_episodes is not None:
            oprot.writeFieldBegin('avg_over_num_episodes', TType.I32, 8)
            oprot.writeI32(self.avg_over_num_episodes)
            oprot.writeFieldEnd()
        if self.offline_train_epochs is not None:
            oprot.writeFieldBegin('offline_train_epochs', TType.I32, 9)
            oprot.writeI32(self.offline_train_epochs)
            oprot.writeFieldEnd()
        if self.epsilon_decay is not None:
            oprot.writeFieldBegin('epsilon_decay', TType.DOUBLE, 10)
            oprot.writeDouble(self.epsilon_decay)
            oprot.writeFieldEnd()
        if self.minimum_epsilon is not None:
            oprot.writeFieldBegin('minimum_epsilon', TType.DOUBLE, 11)
            oprot.writeDouble(self.minimum_epsilon)
            oprot.writeFieldEnd()
        if self.solved_reward_threshold is not None:
            oprot.writeFieldBegin('solved_reward_threshold', TType.I32, 12)
            oprot.writeI32(self.solved_reward_threshold)
            oprot.writeFieldEnd()
        if self.max_episodes_to_run_after_solved is not None:
            oprot.writeFieldBegin('max_episodes_to_run_after_solved', TType.I32, 13)
            oprot.writeI32(self.max_episodes_to_run_after_solved)
            oprot.writeFieldEnd()
        if self.stop_training_after_solved is not None:
            oprot.writeFieldBegin('stop_training_after_solved', TType.BOOL, 14)
            oprot.writeBool(self.stop_training_after_solved)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class NormalizationParameters(object):
    """
    Attributes:
     - feature_type
     - boxcox_lambda
     - boxcox_shift
     - mean
     - stddev
     - possible_values
     - quantiles
     - min_value
     - max_value
    """

    thrift_spec = (
        None,  # 0
        (1, TType.STRING, 'feature_type', 'UTF8', None, ),  # 1
        (2, TType.DOUBLE, 'boxcox_lambda', None, None, ),  # 2
        (3, TType.DOUBLE, 'boxcox_shift', None, None, ),  # 3
        (4, TType.DOUBLE, 'mean', None, None, ),  # 4
        (5, TType.DOUBLE, 'stddev', None, None, ),  # 5
        (6, TType.LIST, 'possible_values', (TType.I64, None, False), None, ),  # 6
        (7, TType.LIST, 'quantiles', (TType.DOUBLE, None, False), None, ),  # 7
        (8, TType.DOUBLE, 'min_value', None, None, ),  # 8
        (9, TType.DOUBLE, 'max_value', None, None, ),  # 9
    )

    def __init__(self, feature_type=None, boxcox_lambda=None, boxcox_shift=None, mean=None, stddev=None, possible_values=None, quantiles=None, min_value=None, max_value=None,):
        self.feature_type = feature_type
        self.boxcox_lambda = boxcox_lambda
        self.boxcox_shift = boxcox_shift
        self.mean = mean
        self.stddev = stddev
        self.possible_values = possible_values
        self.quantiles = quantiles
        self.min_value = min_value
        self.max_value = max_value

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.feature_type = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.DOUBLE:
                    self.boxcox_lambda = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.DOUBLE:
                    self.boxcox_shift = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.DOUBLE:
                    self.mean = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.DOUBLE:
                    self.stddev = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.LIST:
                    self.possible_values = []
                    (_etype133, _size130) = iprot.readListBegin()
                    for _i134 in range(_size130):
                        _elem135 = iprot.readI64()
                        self.possible_values.append(_elem135)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.LIST:
                    self.quantiles = []
                    (_etype139, _size136) = iprot.readListBegin()
                    for _i140 in range(_size136):
                        _elem141 = iprot.readDouble()
                        self.quantiles.append(_elem141)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.DOUBLE:
                    self.min_value = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.DOUBLE:
                    self.max_value = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('NormalizationParameters')
        if self.feature_type is not None:
            oprot.writeFieldBegin('feature_type', TType.STRING, 1)
            oprot.writeString(self.feature_type.encode('utf-8') if sys.version_info[0] == 2 else self.feature_type)
            oprot.writeFieldEnd()
        if self.boxcox_lambda is not None:
            oprot.writeFieldBegin('boxcox_lambda', TType.DOUBLE, 2)
            oprot.writeDouble(self.boxcox_lambda)
            oprot.writeFieldEnd()
        if self.boxcox_shift is not None:
            oprot.writeFieldBegin('boxcox_shift', TType.DOUBLE, 3)
            oprot.writeDouble(self.boxcox_shift)
            oprot.writeFieldEnd()
        if self.mean is not None:
            oprot.writeFieldBegin('mean', TType.DOUBLE, 4)
            oprot.writeDouble(self.mean)
            oprot.writeFieldEnd()
        if self.stddev is not None:
            oprot.writeFieldBegin('stddev', TType.DOUBLE, 5)
            oprot.writeDouble(self.stddev)
            oprot.writeFieldEnd()
        if self.possible_values is not None:
            oprot.writeFieldBegin('possible_values', TType.LIST, 6)
            oprot.writeListBegin(TType.I64, len(self.possible_values))
            for iter142 in self.possible_values:
                oprot.writeI64(iter142)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.quantiles is not None:
            oprot.writeFieldBegin('quantiles', TType.LIST, 7)
            oprot.writeListBegin(TType.DOUBLE, len(self.quantiles))
            for iter143 in self.quantiles:
                oprot.writeDouble(iter143)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.min_value is not None:
            oprot.writeFieldBegin('min_value', TType.DOUBLE, 8)
            oprot.writeDouble(self.min_value)
            oprot.writeFieldEnd()
        if self.max_value is not None:
            oprot.writeFieldBegin('max_value', TType.DOUBLE, 9)
            oprot.writeDouble(self.max_value)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class MDNRNNParameters(object):
    """
    Attributes:
     - hidden_size
     - num_hidden_layers
     - minibatch_size
     - learning_rate
     - num_gaussians
    """

    thrift_spec = (
        None,  # 0
        (1, TType.I32, 'hidden_size', None, 64, ),  # 1
        (2, TType.I32, 'num_hidden_layers', None, 2, ),  # 2
        (3, TType.I32, 'minibatch_size', None, 16, ),  # 3
        (4, TType.DOUBLE, 'learning_rate', None, 0.001, ),  # 4
        (5, TType.I32, 'num_gaussians', None, 5, ),  # 5
    )

    def __init__(self, hidden_size=thrift_spec[1][4], num_hidden_layers=thrift_spec[2][4], minibatch_size=thrift_spec[3][4], learning_rate=thrift_spec[4][4], num_gaussians=thrift_spec[5][4],):
        self.hidden_size = hidden_size
        self.num_hidden_layers = num_hidden_layers
        self.minibatch_size = minibatch_size
        self.learning_rate = learning_rate
        self.num_gaussians = num_gaussians

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.hidden_size = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.num_hidden_layers = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.minibatch_size = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.DOUBLE:
                    self.learning_rate = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I32:
                    self.num_gaussians = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('MDNRNNParameters')
        if self.hidden_size is not None:
            oprot.writeFieldBegin('hidden_size', TType.I32, 1)
            oprot.writeI32(self.hidden_size)
            oprot.writeFieldEnd()
        if self.num_hidden_layers is not None:
            oprot.writeFieldBegin('num_hidden_layers', TType.I32, 2)
            oprot.writeI32(self.num_hidden_layers)
            oprot.writeFieldEnd()
        if self.minibatch_size is not None:
            oprot.writeFieldBegin('minibatch_size', TType.I32, 3)
            oprot.writeI32(self.minibatch_size)
            oprot.writeFieldEnd()
        if self.learning_rate is not None:
            oprot.writeFieldBegin('learning_rate', TType.DOUBLE, 4)
            oprot.writeDouble(self.learning_rate)
            oprot.writeFieldEnd()
        if self.num_gaussians is not None:
            oprot.writeFieldBegin('num_gaussians', TType.I32, 5)
            oprot.writeI32(self.num_gaussians)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
